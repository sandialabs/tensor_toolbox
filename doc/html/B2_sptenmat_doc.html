
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Converting sparse tensors to matrices and vice versa</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-02-03"><meta name="DC.source" content="B2_sptenmat_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Converting sparse tensors to matrices and vice versa</h1><!--introduction--><p>We show how to convert a sptensor to a matrix stored in <i>coordinate</i> format and with extra information so that it can be converted back to a sptensor.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Creating a sptenmat (sparse tensor as sparse matrix) object</a></li><li><a href="#11">Constituent parts of a sptenmat</a></li><li><a href="#16">Creating a sptenmat from its constituent parts</a></li><li><a href="#18">Creating a sptenmat with no nonzeros</a></li><li><a href="#19">Creating an emtpy sptenmat</a></li><li><a href="#20">Use double to convert a sptenmat to a MATLAB sparse matrix</a></li><li><a href="#24">Use full to convert a sptenmat to a tenmat</a></li><li><a href="#26">Use sptensor to convert a sptenmat to a sptensor</a></li><li><a href="#27">Use size and tsize for the dimensions of a sptenmat</a></li><li><a href="#28">Subscripted reference for a sptenmat</a></li><li><a href="#29">Subscripted assignment for a sptenmat</a></li><li><a href="#30">Use end for the last index</a></li><li><a href="#31">Basic operations for sptenmat</a></li><li><a href="#34">Use aatx to efficiently compute A * A' * x for a sptenmat</a></li><li><a href="#36">Displaying a tenmat</a></li></ul></div><h2>Creating a sptenmat (sparse tensor as sparse matrix) object<a name="1"></a></h2><p>A sparse tensor can be converted to a sparse matrix. The matrix, however, is not stored as a MATLAB sparse matrix because that format is sometimes inefficient for converted sparse tensors. Instead, the row and column indices are stored explicitly.</p><p>First, we create a sparse tensor to be converted.</p><pre class="codeinput">X = sptenrand([10 10 10 10],10) <span class="comment">%&lt;-- Generate some data.</span>
</pre><pre class="codeoutput">X is a sparse tensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	( 1, 2, 4, 7)    0.4093
	( 1, 9, 2,10)    0.4635
	( 3, 4, 8, 9)    0.6109
	( 3,10, 9, 7)    0.0712
	( 5, 1, 5, 4)    0.3143
	( 5, 6, 9, 3)    0.6084
	( 6, 6, 5, 5)    0.1750
	( 6, 7, 2, 5)    0.6210
	( 7, 5, 1, 8)    0.2460
	(10, 9,10, 2)    0.5874
</pre><p>All the same options for tenmat are available as for tenmat.</p><pre class="codeinput">A = sptenmat(X,1) <span class="comment">%&lt;-- Mode-1 matricization.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 1 ] (modes of tensor corresponding to rows)
	A.cindices = [ 2  3  4 ] (modes of tensor corresponding to columns)
	( 1,632)	0.409274
	( 1,919)	0.463526
	( 3,874)	0.610944
	( 3,690)	0.0711685
	( 5,341)	0.31428
	( 5,286)	0.608384
	( 6,446)	0.17502
	( 6,417)	0.621027
	( 7,705)	0.24596
	(10,199)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,[2 3]) <span class="comment">%&lt;-- More than one mode is mapped to the columns.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 2  3 ] (modes of tensor corresponding to rows)
	A.cindices = [ 1  4 ] (modes of tensor corresponding to columns)
	(32,61)	0.409274
	(19,91)	0.463526
	(74,83)	0.610944
	(90,63)	0.0711685
	(41,35)	0.31428
	(86,25)	0.608384
	(46,46)	0.17502
	(17,46)	0.621027
	( 5,77)	0.24596
	(99,20)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,[2 3],<span class="string">'t'</span>) <span class="comment">%&lt;-- Specify column dimensions (transpose).</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 1  4 ] (modes of tensor corresponding to rows)
	A.cindices = [ 2  3 ] (modes of tensor corresponding to columns)
	(61,32)	0.409274
	(91,19)	0.463526
	(83,74)	0.610944
	(63,90)	0.0711685
	(35,41)	0.31428
	(25,86)	0.608384
	(46,46)	0.17502
	(46,17)	0.621027
	(77, 5)	0.24596
	(20,99)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,1:4) <span class="comment">%&lt;-- All modes mapped to rows, i.e., vectorize.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 1  2  3  4 ] (modes of tensor corresponding to rows)
	A.cindices = [  ] (modes of tensor corresponding to columns)
	(6311,1)	0.409274
	(9181,1)	0.463526
	(8733,1)	0.610944
	(6893,1)	0.0711685
	(3405,1)	0.31428
	(2855,1)	0.608384
	(4456,1)	0.17502
	(4166,1)	0.621027
	(7047,1)	0.24596
	(1990,1)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,2) <span class="comment">%&lt;-- By default, columns are ordered as [1 3 4].</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 2 ] (modes of tensor corresponding to rows)
	A.cindices = [ 1  3  4 ] (modes of tensor corresponding to columns)
	( 2,631)	0.409274
	( 9,911)	0.463526
	( 4,873)	0.610944
	(10,683)	0.0711685
	( 1,345)	0.31428
	( 6,285)	0.608384
	( 6,446)	0.17502
	( 7,416)	0.621027
	( 5,707)	0.24596
	( 9,200)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,2,[3 1 4]) <span class="comment">%&lt;-- Explicit column ordering.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 2 ] (modes of tensor corresponding to rows)
	A.cindices = [ 3  1  4 ] (modes of tensor corresponding to columns)
	( 2,604)	0.409274
	( 9,902)	0.463526
	( 4,828)	0.610944
	(10,629)	0.0711685
	( 1,345)	0.31428
	( 6,249)	0.608384
	( 6,455)	0.17502
	( 7,452)	0.621027
	( 5,761)	0.24596
	( 9,200)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,2,<span class="string">'fc'</span>) <span class="comment">%&lt;-- Foward cyclic.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 2 ] (modes of tensor corresponding to rows)
	A.cindices = [ 3  4  1 ] (modes of tensor corresponding to columns)
	( 2, 64)	0.409274
	( 9, 92)	0.463526
	( 4,288)	0.610944
	(10,269)	0.0711685
	( 1,435)	0.31428
	( 6,429)	0.608384
	( 6,545)	0.17502
	( 7,542)	0.621027
	( 5,671)	0.24596
	( 9,920)	0.587358
</pre><pre class="codeinput">A = sptenmat(X,2,<span class="string">'bc'</span>) <span class="comment">%&lt;-- Backward cyclic.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 2 ] (modes of tensor corresponding to rows)
	A.cindices = [ 1  4  3 ] (modes of tensor corresponding to columns)
	( 2,361)	0.409274
	( 9,191)	0.463526
	( 4,783)	0.610944
	(10,863)	0.0711685
	( 1,435)	0.31428
	( 6,825)	0.608384
	( 6,446)	0.17502
	( 7,146)	0.621027
	( 5, 77)	0.24596
	( 9,920)	0.587358
</pre><h2>Constituent parts of a sptenmat<a name="11"></a></h2><pre class="codeinput">A.subs <span class="comment">%&lt;-- Subscripts of the nonzeros.</span>
</pre><pre class="codeoutput">ans =
     2   361
     9   191
     4   783
    10   863
     1   435
     6   825
     6   446
     7   146
     5    77
     9   920
</pre><pre class="codeinput">A.vals <span class="comment">%&lt;-- The corresponding nonzero values.</span>
</pre><pre class="codeoutput">ans =
    0.4093
    0.4635
    0.6109
    0.0712
    0.3143
    0.6084
    0.1750
    0.6210
    0.2460
    0.5874
</pre><pre class="codeinput">A.tsize <span class="comment">%&lt;-- Size of the original tensor.</span>
</pre><pre class="codeoutput">ans =
    10    10    10    10
</pre><pre class="codeinput">A.rdims <span class="comment">%&lt;-- Dimensions that were mapped to the rows.</span>
</pre><pre class="codeoutput">ans =
     2
</pre><pre class="codeinput">A.cdims <span class="comment">%&lt;-- Dimensions that were mapped to the columns.</span>
</pre><pre class="codeoutput">ans =
     1     4     3
</pre><h2>Creating a sptenmat from its constituent parts<a name="16"></a></h2><pre class="codeinput">B = sptenmat(A.subs,A.vals,A.rdims,A.cdims,A.tsize) <span class="comment">%&lt;-- Copies A</span>
</pre><pre class="codeoutput">B is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	B.rindices = [ 2 ] (modes of tensor corresponding to rows)
	B.cindices = [ 1  4  3 ] (modes of tensor corresponding to columns)
	( 1,435)	0.31428
	( 2,361)	0.409274
	( 4,783)	0.610944
	( 5, 77)	0.24596
	( 6,446)	0.17502
	( 6,825)	0.608384
	( 7,146)	0.621027
	( 9,191)	0.463526
	( 9,920)	0.587358
	(10,863)	0.0711685
</pre><pre class="codeinput">B = sptenmat(double(A),A.rdims,A.cdims,A.tsize) <span class="comment">%&lt;-- More efficient to pass a matrix.</span>
</pre><pre class="codeoutput">B is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	B.rindices = [ 2 ] (modes of tensor corresponding to rows)
	B.cindices = [ 1  4  3 ] (modes of tensor corresponding to columns)
	( 5, 77)	0.24596
	( 7,146)	0.621027
	( 9,191)	0.463526
	( 2,361)	0.409274
	( 1,435)	0.31428
	( 6,446)	0.17502
	( 4,783)	0.610944
	( 6,825)	0.608384
	(10,863)	0.0711685
	( 9,920)	0.587358
</pre><h2>Creating a sptenmat with no nonzeros<a name="18"></a></h2><pre class="codeinput">A = sptenmat([],[],A.rdims,A.cdims,A.tsize) <span class="comment">%&lt;-- An empty sptenmat.</span>
</pre><pre class="codeoutput">A is an all-zero sptenmat from an sptensor of size 10 x 10 x 10 x 10
	A.rindices = [ 2 ] (modes of tensor corresponding to rows)
	A.cindices = [ 1  4  3 ] (modes of tensor corresponding to columns)
</pre><h2>Creating an emtpy sptenmat<a name="19"></a></h2><pre class="codeinput">A = sptenmat <span class="comment">%&lt;-- A really empty sptenmat.</span>
</pre><pre class="codeoutput">A is an all-zero sptenmat from an sptensor of size [empty tensor]
	A.rindices = [  ] (modes of tensor corresponding to rows)
	A.cindices = [  ] (modes of tensor corresponding to columns)
</pre><h2>Use double to convert a sptenmat to a MATLAB sparse matrix<a name="20"></a></h2><pre class="codeinput">X = sptenrand([10 10 10 10],10); <span class="comment">%&lt;-- Create a tensor.</span>
A = sptenmat(X,1) <span class="comment">%&lt;-- Convert it to a sptenmat</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	A.rindices = [ 1 ] (modes of tensor corresponding to rows)
	A.cindices = [ 2  3  4 ] (modes of tensor corresponding to columns)
	( 3,388)	0.851845
	( 4, 41)	0.759479
	( 4,313)	0.949759
	( 4,445)	0.557939
	( 5,495)	0.014233
	( 5,487)	0.596177
	( 5,578)	0.816206
	( 6,774)	0.977092
	( 6,326)	0.221908
	(10,592)	0.703684
</pre><pre class="codeinput">B = double(A) <span class="comment">%&lt;-- Convert it to a MATLAB sparse matrix</span>
</pre><pre class="codeoutput">B =
   (4,41)      0.7595
   (4,313)     0.9498
   (6,326)     0.2219
   (3,388)     0.8518
   (4,445)     0.5579
   (5,487)     0.5962
   (5,495)     0.0142
   (5,578)     0.8162
  (10,592)     0.7037
   (6,774)     0.9771
</pre><pre class="codeinput">whos <span class="string">A</span> <span class="string">B</span> <span class="comment">%&lt;-- The storage for B (the sparse matrix) is larger than for A.</span>
</pre><pre class="codeoutput">  Name       Size              Bytes  Class       Attributes

  A         10x1000             1184  sptenmat              
  B         10x1000             8168  double      sparse    

</pre><pre class="codeinput">C = B'; <span class="comment">%&lt;-- Transposing the result fixes the problem.</span>
whos <span class="string">C</span>
</pre><pre class="codeoutput">  Name         Size            Bytes  Class     Attributes

  C         1000x10              248  double    sparse    

</pre><h2>Use full to convert a sptenmat to a tenmat<a name="24"></a></h2><pre class="codeinput">B = sptenmat(sptenrand([3 3 3], 3), 1) <span class="comment">%&lt;-- Create a sptenmat</span>
</pre><pre class="codeoutput">B is a sptenmat from an sptensor of size 3 x 3 x 3 with 3 nonzeros
	B.rindices = [ 1 ] (modes of tensor corresponding to rows)
	B.cindices = [ 2  3 ] (modes of tensor corresponding to columns)
	(2,7)	0.755339
	(3,1)	0.894813
	(3,5)	0.28615
</pre><pre class="codeinput">C = full(B) <span class="comment">%&lt;-- Convert to a tenmat</span>
</pre><pre class="codeoutput">C is a matrix corresponding to a tensor of size 3 x 3 x 3
	C.rindices = [ 1 ] (modes of tensor corresponding to rows)
	C.cindices = [ 2  3 ] (modes of tensor corresponding to columns)
	C.data = 
		  Columns 1 through 7
		         0         0         0         0         0         0         0
		         0         0         0         0         0         0    0.7553
		    0.8948         0         0         0    0.2861         0         0
		  Columns 8 through 9
		         0         0
		         0         0
		         0         0
</pre><h2>Use sptensor to convert a sptenmat to a sptensor<a name="26"></a></h2><pre class="codeinput">Y = sptensor(A) <span class="comment">%&lt;-- Convert a sptenmat to a sptensor</span>
</pre><pre class="codeoutput">Y is a sparse tensor of size 10 x 10 x 10 x 10 with 10 nonzeros
	( 3,8, 9,4)    0.8518
	( 4,1, 5,1)    0.7595
	( 4,3, 2,4)    0.9498
	( 4,5, 5,5)    0.5579
	( 5,5,10,5)    0.0142
	( 5,7, 9,5)    0.5962
	( 5,8, 8,6)    0.8162
	( 6,4, 8,8)    0.9771
	( 6,6, 3,4)    0.2219
	(10,2,10,6)    0.7037
</pre><h2>Use size and tsize for the dimensions of a sptenmat<a name="27"></a></h2><pre class="codeinput">size(A) <span class="comment">%&lt;-- Matrix size</span>
tsize(A) <span class="comment">%&lt;-- Corresponding tensor size</span>
</pre><pre class="codeoutput">ans =
          10        1000
ans =
    10    10    10    10
</pre><h2>Subscripted reference for a sptenmat<a name="28"></a></h2><p>This is not supported beyond getting the constituent parts.</p><h2>Subscripted assignment for a sptenmat<a name="29"></a></h2><pre class="codeinput">A(1:2,1:2) = ones(2) <span class="comment">%&lt;-- Replace part of the matrix.</span>
</pre><pre class="codeoutput">A is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 14 nonzeros
	A.rindices = [ 1 ] (modes of tensor corresponding to rows)
	A.cindices = [ 2  3  4 ] (modes of tensor corresponding to columns)
	( 1,  1)	1
	( 1,  2)	1
	( 2,  1)	1
	( 2,  2)	1
	( 3,388)	0.851845
	( 4, 41)	0.759479
	( 4,313)	0.949759
	( 4,445)	0.557939
	( 5,487)	0.596177
	( 5,495)	0.014233
	( 5,578)	0.816206
	( 6,326)	0.221908
	( 6,774)	0.977092
	(10,592)	0.703684
</pre><h2>Use end for the last index<a name="30"></a></h2><p>End is not supported.</p><h2>Basic operations for sptenmat<a name="31"></a></h2><pre class="codeinput">norm(A) <span class="comment">%&lt;-- Norm of the matrix.</span>
</pre><pre class="codeoutput">ans =
    3.0061
</pre><pre class="codeinput">+A <span class="comment">%&lt;-- Calls uplus.</span>
</pre><pre class="codeoutput">ans is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 14 nonzeros
	ans.rindices = [ 1 ] (modes of tensor corresponding to rows)
	ans.cindices = [ 2  3  4 ] (modes of tensor corresponding to columns)
	( 1,  1)	1
	( 1,  2)	1
	( 2,  1)	1
	( 2,  2)	1
	( 3,388)	0.851845
	( 4, 41)	0.759479
	( 4,313)	0.949759
	( 4,445)	0.557939
	( 5,487)	0.596177
	( 5,495)	0.014233
	( 5,578)	0.816206
	( 6,326)	0.221908
	( 6,774)	0.977092
	(10,592)	0.703684
</pre><pre class="codeinput">-A <span class="comment">%&lt;-- Calls uminus.</span>
</pre><pre class="codeoutput">ans is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 14 nonzeros
	ans.rindices = [ 1 ] (modes of tensor corresponding to rows)
	ans.cindices = [ 2  3  4 ] (modes of tensor corresponding to columns)
	( 1,  1)	-1
	( 1,  2)	-1
	( 2,  1)	-1
	( 2,  2)	-1
	( 3,388)	-0.851845
	( 4, 41)	-0.759479
	( 4,313)	-0.949759
	( 4,445)	-0.557939
	( 5,487)	-0.596177
	( 5,495)	-0.014233
	( 5,578)	-0.816206
	( 6,326)	-0.221908
	( 6,774)	-0.977092
	(10,592)	-0.703684
</pre><h2>Use aatx to efficiently compute A * A' * x for a sptenmat<a name="34"></a></h2><pre class="codeinput">x = ones(10,1); <span class="comment">%&lt;-- Create vector</span>
aatx(A,x) <span class="comment">%&lt;-- Compute A * A' * x</span>
</pre><pre class="codeoutput">ans =
    4.0000
    4.0000
    0.7256
    1.7901
    1.0218
    1.0040
         0
         0
         0
    0.4952
</pre><pre class="codeinput">double(A) * double(A)' * x <span class="comment">%&lt;-- Same as above but less efficient</span>
</pre><pre class="codeoutput">ans =
    4.0000
    4.0000
    0.7256
    1.7901
    1.0218
    1.0040
         0
         0
         0
    0.4952
</pre><h2>Displaying a tenmat<a name="36"></a></h2><p>Shows the original tensor dimensions, the modes mapped to rows, the modes mapped to columns, and the matrix.</p><pre class="codeinput">disp(A)
</pre><pre class="codeoutput">ans is a sptenmat from an sptensor of size 10 x 10 x 10 x 10 with 14 nonzeros
	ans.rindices = [ 1 ] (modes of tensor corresponding to rows)
	ans.cindices = [ 2  3  4 ] (modes of tensor corresponding to columns)
	( 1,  1)	1
	( 1,  2)	1
	( 2,  1)	1
	( 2,  2)	1
	( 3,388)	0.851845
	( 4, 41)	0.759479
	( 4,313)	0.949759
	( 4,445)	0.557939
	( 5,487)	0.596177
	( 5,495)	0.014233
	( 5,578)	0.816206
	( 6,326)	0.221908
	( 6,774)	0.977092
	(10,592)	0.703684
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Converting sparse tensors to matrices and vice versa
% We show how to convert a sptensor to a matrix stored in _coordinate_
% format and with extra information so that it can be converted back to a
% sptensor.

%% Creating a sptenmat (sparse tensor as sparse matrix) object
% A sparse tensor can be converted to a sparse matrix. The matrix, however,
% is not stored as a MATLAB sparse matrix because that format is sometimes
% inefficient for converted sparse tensors. Instead, the row and column
% indices are stored explicitly.
%%
% First, we create a sparse tensor to be converted.
X = sptenrand([10 10 10 10],10) %<REPLACE_WITH_DASH_DASH Generate some data.
%%
% All the same options for tenmat are available as for tenmat.
A = sptenmat(X,1) %<REPLACE_WITH_DASH_DASH Mode-1 matricization.
%%
A = sptenmat(X,[2 3]) %<REPLACE_WITH_DASH_DASH More than one mode is mapped to the columns.
%%
A = sptenmat(X,[2 3],'t') %<REPLACE_WITH_DASH_DASH Specify column dimensions (transpose).
%%
A = sptenmat(X,1:4) %<REPLACE_WITH_DASH_DASH All modes mapped to rows, i.e., vectorize.
%%
A = sptenmat(X,2) %<REPLACE_WITH_DASH_DASH By default, columns are ordered as [1 3 4].
%% 
A = sptenmat(X,2,[3 1 4]) %<REPLACE_WITH_DASH_DASH Explicit column ordering.
%%
A = sptenmat(X,2,'fc') %<REPLACE_WITH_DASH_DASH Foward cyclic.
%%
A = sptenmat(X,2,'bc') %<REPLACE_WITH_DASH_DASH Backward cyclic.
%% Constituent parts of a sptenmat
A.subs %<REPLACE_WITH_DASH_DASH Subscripts of the nonzeros.
%%
A.vals %<REPLACE_WITH_DASH_DASH The corresponding nonzero values.
%%
A.tsize %<REPLACE_WITH_DASH_DASH Size of the original tensor.
%%
A.rdims %<REPLACE_WITH_DASH_DASH Dimensions that were mapped to the rows.
%%
A.cdims %<REPLACE_WITH_DASH_DASH Dimensions that were mapped to the columns.
%% Creating a sptenmat from its constituent parts
B = sptenmat(A.subs,A.vals,A.rdims,A.cdims,A.tsize) %<REPLACE_WITH_DASH_DASH Copies A
%%
B = sptenmat(double(A),A.rdims,A.cdims,A.tsize) %<REPLACE_WITH_DASH_DASH More efficient to pass a matrix.
%% Creating a sptenmat with no nonzeros
A = sptenmat([],[],A.rdims,A.cdims,A.tsize) %<REPLACE_WITH_DASH_DASH An empty sptenmat.
%% Creating an emtpy sptenmat
A = sptenmat %<REPLACE_WITH_DASH_DASH A really empty sptenmat.
%% Use double to convert a sptenmat to a MATLAB sparse matrix
X = sptenrand([10 10 10 10],10); %<REPLACE_WITH_DASH_DASH Create a tensor.
A = sptenmat(X,1) %<REPLACE_WITH_DASH_DASH Convert it to a sptenmat
%%
B = double(A) %<REPLACE_WITH_DASH_DASH Convert it to a MATLAB sparse matrix
%%
whos A B %<REPLACE_WITH_DASH_DASH The storage for B (the sparse matrix) is larger than for A.
%%
C = B'; %<REPLACE_WITH_DASH_DASH Transposing the result fixes the problem.
whos C
%% Use full to convert a sptenmat to a tenmat
B = sptenmat(sptenrand([3 3 3], 3), 1) %<REPLACE_WITH_DASH_DASH Create a sptenmat
%%
C = full(B) %<REPLACE_WITH_DASH_DASH Convert to a tenmat
%% Use sptensor to convert a sptenmat to a sptensor
Y = sptensor(A) %<REPLACE_WITH_DASH_DASH Convert a sptenmat to a sptensor
%% Use size and tsize for the dimensions of a sptenmat
size(A) %<REPLACE_WITH_DASH_DASH Matrix size
tsize(A) %<REPLACE_WITH_DASH_DASH Corresponding tensor size
%% Subscripted reference for a sptenmat
% This is not supported beyond getting the constituent parts.
%% Subscripted assignment for a sptenmat
A(1:2,1:2) = ones(2) %<REPLACE_WITH_DASH_DASH Replace part of the matrix.
%% Use end for the last index
% End is not supported.
%% Basic operations for sptenmat
norm(A) %<REPLACE_WITH_DASH_DASH Norm of the matrix.
%%
+A %<REPLACE_WITH_DASH_DASH Calls uplus.
%%
-A %<REPLACE_WITH_DASH_DASH Calls uminus.
%% Use aatx to efficiently compute A * A' * x for a sptenmat
x = ones(10,1); %<REPLACE_WITH_DASH_DASH Create vector
aatx(A,x) %<REPLACE_WITH_DASH_DASH Compute A * A' * x
%%
double(A) * double(A)' * x %<REPLACE_WITH_DASH_DASH Same as above but less efficient
%% Displaying a tenmat
% Shows the original tensor dimensions, the modes mapped to rows, the modes
% mapped to columns, and the matrix.
disp(A) 

##### SOURCE END #####
--></body></html>